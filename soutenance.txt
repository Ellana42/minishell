Compilation
- Minishell compile sans erreurs si les flags ne sont pas utilises

Commandes simples
- executer une commande simple avec un path absolue comme /bin/ls ou n'importe quelle autre commande
  sans options
- commande vide
- commande avec seulement espaces ou tabs

Arguments & historiques
- executer une commande simple avec un path absolue comme /bin/ls ou n'importe quelle autre commande avec
  arguments mais sans quotes et guillemets
- tester plusieurs fois avec differents argcs & commandes

echo
- executer la commande avec ou sans arguments ou -n
- repeter plusieurs fois avec differents arguments

exit
- executer la commande avec ou sans arguments
- repeter plusieurs fois avec differents arguments
- relaunch le minishell

Valeurs de retours d'un processus
- executer une commande simple avec un path absolue comme /bin/ls ou n'importe quelle autre commande avec
  arguments mais sans quotes et guillemets puis executer echo $?
- Verifier la valeur affichee. Refaire la meme chose dans bash et comparer
- Repeter plusieurs fois avec differentes commandes & argcs, utiliser des commandes fails comme 
  /bin/ls/fichier_qui_nexiste_pas
- expr $? + $?

Signaux
- ctrl-C dans un prompt vide doit montrer une nouvelle ligne avec un new prompt
- ctrl-\ ne fait rien dans un prompt vide
- ctrl-D dans un prompt vide doit quitter Minishell --> relaunch
- ctrl-C dans un prompt apres avoir ecrit qqch doit montrer une nouvelle ligne avec un nouveau prompt
- ctrl-C apres une commande bloquante comme cat ou grep sans arguments
- ctrl-\ apres une commande bloquante comme cat ou grep sans arguments
- ctrl-D apres une commande bloquante comme cat ou grep sans arguments

Guillemets
- Executer une commande simple avec arguments entre " " (whitespace inclus)
  Exemple : echo "cat lol.c | cat > lol.c"
- Tout sauf $

Quotes
- Executer des commandes avec des quotes comme argcs
- Tester des arguments vides
- Tester les variables d'environnement, les whitespaces, pipes, redirections en simple quote
- echo '$USER' doit print $USER
- Rien ne doit etre interprete

env
- checker si l'env montre les variables d'environnement actuelles

export
- exporter les variables d'environnement, en creer de nouvelles, remplacer les anciennes
- les checker avec env

unset
- exporter les variables d'environnement, en creer de nouvelles, remplacer les anciennes
- utiliser unset pour les enlever
- checker le resultat avec env

cd
- est utilisee pour se deplacer dans le working directory et checker si on est dans le bon repertoire
  avec /bin/ls
- Repeter plusieurs fois avec un cd qui marche et qui ne marche pas
- '.' '..' doivent etre testes

pwd
- utiliser la commande
- la tester dans differents directories

Path relatif
- executer les commandes mais cette fois comme paths relatifs
- repeter plusieurs fois dans differents directories avec des paths relatifs complexes (beaucoup de ..)

Path d'environnement
- Executer les commandes mais cette fois sans aucuns paths (ls, wc, awk, etc.)
- Unset le $PATH et checker si marche toujours
- Set le $PATH a des repertoires differents (directory1:directory2) et verifier que les repertoires sont checkes
  dans l'odre de gauche a droite

Redirections
- Executer les commandes avec des redirections comme < et >
- Tester differentes commandes et differents argcs, >>
- Verifier que plusieurs occurences de la meme redirection fail
- << ne doit pas update l'historique

Pipes
- cat file | grep bla | more
- commande fail comme ls file_qui_n'existe_pas | grep bla | more
- Melanger les pipes avec les redirections et tester

Historique
- taper une ligne de commande puis use ctrl-C puis appuyer sur enter : le buffer doit etre clean et rien ne
  doit tenter d'etre exe
- up et down permet de naviguer dans commandes
- tester des commandes pas censees marchees comme 'dhsjdfhjkal', le shell ne doit pas crasher et afficher une
  erreur
- tester des longues commandes avec bcp d'arguments

Variables d'environnement
- echo avec des variables $ comme arguments
- $ doit etre interprete comme une variable d'environnement
- les guillemets interpolent le $
- check si $USER existe ou le set
- echo "$USER" doit print la valeur de $USER
